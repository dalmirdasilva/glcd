/**
 * Glcd project
 * 
 * interrupt.h
 * 
 * Contains a simple interrupt handler for general purposes.
 * 
 * @author  Dalmir da Silva <dalmirdasilva@gmail.com>
 */

#ifndef __PIC_LEDCUBE_INTERRUPT_H
#define __PIC_LEDCUBE_INTERRUPT_H 1 

#include <signal.h>

DEF_INTHIGH(high_interrupt_vector)
    DEF_HANDLER(SIG_TMR0, timer_0_handler)
END_DEF

uint16_t ps = 0x0f00;

/*
 * Multiplexer/framebuffer routine
 * 
 * This function is called by an interrupt generated by timer 0.
 */
SIGHANDLER(timer_0_handler) {
  
    // Clear interrupt flag
    INTCONbits.T0IF = 0;
    
    // Commits the buffer into the glcd module
    glcd_buffered_commit();

    // Toggle led 0 every 1000 interruptions
    if(ps++ == 0x0ff0) {
        ps = 0;
        lcd_put_string_at("SIG STATUS:", 0, 0, 100);
        lcd_position(0, 1);
        if(glcd_get_out_of_range_flag()) {
            lcd_put_string("or:1,", 100);
        } else {
            lcd_put_string("or:0,", 100);
        }
        if(glcd_get_write_timeout_flag()) {
            lcd_put_string("wt:1,", 100);
        } else {
            lcd_put_string("wt:0,", 100);
        }
        if(glcd_get_read_in_all_chips()) {
            lcd_put_string("ra:1", 100);
        } else {
            lcd_put_string("ra:0", 100);
        }
        delay_ms(1000);
    }
}

#endif // __PIC_LEDCUBE_INTERRUPT_H

